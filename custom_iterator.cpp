//
//  custom_iterator.cpp
//  PA5
//
//  Created by Maxim Anaya on 5/6/16.
//  Copyright Â© 2016 Maxim Anaya. All rights reserved.
//

#include "custom_iterator.h"
/*

namespace CS2312
{
    // fixed_array
    template<class T> inline fixed_array<T>::fixed_array(size_type size)
    {
        __size = size;
    }
    
    template<class T> inline fixed_array<T>::fixed_array(std::initializer_list<T> list)
    {
        __data = list;
    }
    
    template<class T> inline fixed_array<T>::~fixed_array()
    {
        delete __data;
    }
    
    template<class T> inline std::size_t fixed_array<T>::size() const
    {
        return __size;
    }
    
    template<class T> inline T& fixed_array<T>::operator[](size_t index)
    {
        return __data[index];
    }
    
    template<class T> inline const T& fixed_array<T>::operator[](size_t index) const
    {
        return __data[index];
    }
    
    template<class T> typename fixed_array<T>::iterator fixed_array<T>::begin()
    {
        
    }
    
    template<class T> typename fixed_array<T>::iterator fixed_array<T>::end()
    {
        
    }
    
    template<class T> typename fixed_array<T>::const_iterator fixed_array<T>::begin() const
    {
        
    }
    
    template<class T> typename fixed_array<T>::const_iterator fixed_array<T>::end() const
    {
        
    }
    
    
    
    
    
    
    
    
    
    // iterator
    template<class T> inline fixed_array<T>::iterator::iterator(pointer ptr)
    {
        __ptr = ptr;
    }
    
    template<class T> inline
    typename fixed_array<T>::iterator::self_type fixed_array<T>::iterator::operator++()
    {
        return *this;
    }
    
    template<class T> inline
    typename fixed_array<T>::iterator::self_type fixed_array<T>::iterator::operator++(int junk)
    {
        return *this;
    }
    
    template<class T> inline
    typename fixed_array<T>::iterator::reference fixed_array<T>::iterator::operator*()
    {
        return *__ptr;
    }
    
    template<class T> inline
    typename fixed_array<T>::iterator::pointer fixed_array<T>::iterator::operator->()
    {
        return __ptr;
    }
    
    template<class T> inline
    bool fixed_array<T>::iterator::operator==(const self_type& rhs) const
    {
        return  false;//*__ptr == rhs->;
    }
    
    template<class T> inline
    bool fixed_array<T>::iterator::operator!=(const self_type& rhs) const
    {
        
    }
    
    
    
    
    
    
    
    
    
    
    
    // const_iterator
    template<class T> inline fixed_array<T>::const_iterator::const_iterator(pointer ptr)
    {
        __ptr = ptr;
    }
    
    template<class T> inline
    typename fixed_array<T>::const_iterator::self_type fixed_array<T>::const_iterator::operator++()
    {
        return *this;
    }
    
    template<class T> inline
    typename fixed_array<T>::const_iterator::self_type fixed_array<T>::const_iterator::operator++(int junk)
    {
        return *this;
    }
    
    template<class T> inline
    const typename fixed_array<T>::const_iterator::value_type& fixed_array<T>::const_iterator::operator*() const
    {
        return *__ptr;
    }
    
    template<class T> inline
    const typename fixed_array<T>::const_iterator::value_type* fixed_array<T>::const_iterator::operator->() const
    {
        return __ptr;
    }
    
    template<class T> inline
    bool fixed_array<T>::const_iterator::operator==(const self_type& rhs) const
    {
        return  false; // NOT DONE
    }
    
    template<class T> inline
    bool fixed_array<T>::const_iterator::operator!=(const self_type& rhs) const
    {
        return false;
    }
}*/
